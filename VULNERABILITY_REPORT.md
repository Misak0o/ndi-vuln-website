# Rapport de Vulnérabilité : Clé Secrète Faible dans les JWT (HS256)

Ce document détaille la vulnérabilité de l'utilisation d'une clé secrète faible avec l'algorithme de signature `HS256` pour les JSON Web Tokens (JWT).

## 1. Le Fonctionnement de la Faille

### Qu'est-ce qu'un JWT ?
Un JWT est une chaîne de caractères compacte et standardisée (RFC 7519) utilisée pour transmettre de manière sécurisée des informations entre deux parties. Il est composé de trois parties séparées par des points :
1.  **Header (En-tête)** : Contient les métadonnées du token, comme l'algorithme de signature utilisé (ex: `HS256`).
2.  **Payload (Données utiles)** : Contient les "claims" ou déclarations, qui sont les informations que l'on souhaite transmettre (ex: `{"role": "guest"}`).
3.  **Signature** : Une chaîne de caractères calculée pour vérifier l'intégrité du message.

### La Vulnérabilité du `HS256` avec un Secret Faible
L'algorithme `HS256` est un algorithme de signature **symétrique**. Cela signifie qu'une seule et même clé secrète est utilisée pour **créer** la signature et pour la **vérifier**.

La signature est calculée comme suit :
`Signature = HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret )`

La faille critique apparaît lorsque le `secret` utilisé est :
-   **Court, simple ou facilement devinable** (ex: "secret", "12345", "password").
-   **Laissé en clair dans le code source** (côté client ou serveur).
-   **Partagé avec des parties non fiables**.

Si un attaquant parvient à obtenir ce secret, il peut créer n'importe quel `payload` (par exemple, en changeant son rôle de `"guest"` à `"admin"`), recalculer une signature valide avec le secret qu'il a trouvé, et ainsi forger un token entièrement nouveau et légitime aux yeux du serveur.

---

## 2. Comment Reproduire la Faille sur le Site

Le site web a été conçu comme un simulateur pour guider l'utilisateur à travers les étapes de l'exploitation de cette faille.

1.  **Obtenir un Token Initial**
    - En arrivant sur la page, le serveur fournit un token JWT pour un utilisateur "guest".

2.  **Analyser le Token**
    - En cliquant sur "Déchiffrer le contenu", l'utilisateur peut voir le contenu du *payload*. Il découvre que cette partie est simplement encodée en Base64 et non chiffrée, révélant la structure des données (`{"role": "guest"}`).

3.  **Trouver le Secret Faible**
    - L'utilisateur doit trouver le secret. Un indice le guide pour inspecter le code source de la page (`index.html`), où un commentaire laissé par un développeur révèle le secret : `"secret"`.
    - L'utilisateur entre ce secret dans le champ prévu pour passer à l'étape suivante.

4.  **Forger un Token Admin**
    - L'utilisateur modifie le *payload* pour s'attribuer le rôle d'administrateur : `{"role": "admin"}`.
    - En cliquant sur "Forger le Token", le site utilise le secret trouvé et le nouveau *payload* pour calculer une nouvelle signature valide et assembler un nouveau token JWT.

5.  **Exploiter le Token Forgé**
    - L'utilisateur utilise ce nouveau token pour faire une requête à la route protégée `/admin` du serveur.
    - Le serveur, utilisant le même secret faible pour vérifier la signature, considère le token comme valide. Comme le *payload* contient `"role": "admin"`, l'accès est accordé.

---

## 3. Comment s'en Protéger en Temps Normal

La protection contre cette faille repose sur une gestion rigoureuse du secret et le choix d'algorithmes appropriés.

1.  **Utiliser un Secret Fort et Complexe**
    - Le secret doit être une chaîne de caractères longue (au moins 32 caractères, 64 étant une bonne cible) et générée de manière aléatoire. Elle ne doit pas être un mot de passe ou une phrase simple.
    - **Exemple de génération en Python :** `import secrets; secrets.token_hex(32)`

2.  **Ne JAMAIS Coder le Secret en Dur**
    - Le secret ne doit jamais se trouver dans le code source (ni côté client, ni côté serveur).
    - **Bonne pratique :** Le charger depuis des **variables d'environnement** ou, mieux encore, un service de gestion de secrets (ex: HashiCorp Vault, AWS Secrets Manager, Azure Key Vault).

3.  **Utiliser des Algorithmes Asymétriques (RS256, PS256)**
    - Pour de nombreuses architectures (microservices, authentification tierce), un algorithme asymétrique est plus sûr.
    - **Fonctionnement :**
        - Le serveur d'authentification signe les tokens avec une **clé privée** qu'il garde secrète.
        - Les autres services qui doivent vérifier les tokens n'ont besoin que de la **clé publique** correspondante.
    - **Avantage :** Même si la clé publique est connue de tous, personne ne peut forger de nouveaux tokens sans la clé privée.

4.  **Mettre en Place une Rotation des Clés**
    - Les secrets et les clés doivent être changés (rotés) régulièrement. Si une clé est compromise, elle ne le sera que pour une durée limitée.

5.  **Définir une Durée de Vie Courte pour les Tokens (`exp`)**
    - Toujours inclure une date d'expiration (`exp`) dans le *payload* du JWT. Une durée de vie courte (ex: 15 minutes) limite la fenêtre d'opportunité pour un attaquant s'il parvient à voler un token.
